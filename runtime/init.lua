--!strict

--- @class Yarn
---
--- Main class for using files generated by YarnSpinnerRbx.
local Yarn = {}

local Dialogue = require(script:WaitForChild("Dialogue"))
local VirtualMachine = require(script:WaitForChild("VirtualMachine"))

local lib = script:WaitForChild("lib")
local Base64 = require(lib:WaitForChild("Base64"))

local types = script:WaitForChild("types")
local RawProgram = require(types:WaitForChild("RawProgram"))
local YarnProgram = require(types:WaitForChild("YarnProgram"))
local DialogueTypes = require(types:WaitForChild("Dialogue"))

-- export these types here for ease of use in generated scripts

--- @type RawProgram RawProgram.RawProgram
--- @within Yarn
---
--- [See full type here.](RawProgram)
export type RawProgram = RawProgram.RawProgram

--- @type Program YarnProgram.YarnProgram
--- @within Yarn
---
--- [See full type here.](YarnProgram)
export type Program = YarnProgram.YarnProgram

--- @type Line Line
--- @within Yarn
---
--- [See full type here.](Dialogue#Line)
export type Line = DialogueTypes.Line

--- @type Option Option
--- @within Yarn
---
--- [See full type here.](Dialogue#Option)
export type Option = DialogueTypes.Option

--- @type LibraryFunction LibraryFunction
--- @within Yarn
---
--- [See full type here.](Dialogue#LibraryFunction)
export type LibraryFunction = DialogueTypes.LibraryFunction

--- @type YarnFunction YarnFunction
--- @within Yarn
---
--- [See full type here.](Dialogue#YarnFunction)
export type YarnFunction = DialogueTypes.YarnFunction

--- @type YarnTypeName YarnType
--- @within Yarn
---
--- [See full type here.](Dialogue#YarnType)
export type YarnTypeName = DialogueTypes.YarnType

--- @type YarnArgument YarnProgram.Operand
--- @within Yarn
---
--- [See full type here.](YarnProgram#Operand)
export type YarnArgument = YarnProgram.Operand

--- @prop Base64 Base64
--- @within Yarn
--- @tag libraries
---
--- Base64 library used by generated modules.
Yarn.Base64 = Base64

--- @prop Dialogue Dialogue
--- @within Yarn
--- @tag libraries
---
--- Dialogue library used for running a Yarn script.
Yarn.Dialogue = Dialogue

--- @prop VirtualMachine VirtualMachine
--- @within Yarn
--- @tag libraries
---
--- Virtual machine library used for executing Yarn instructions.
Yarn.VirtualMachine = VirtualMachine

--- @private
--- @within Yarn
--- Turn a Protobuf operand into the union typed operand
local function getOperand(operand: RawProgram.Operand): YarnProgram.Operand
	return if operand.boolValue ~= nil
		then operand.boolValue
		elseif operand.floatValue ~= nil then operand.floatValue
		elseif operand.stringValue ~= nil then operand.stringValue
		else error("Operand has no value!")
end

--- @private
--- @within Yarn
--- Decode a list of Protobuf instructions into a simpler form
local function decodeInstructions(code: { RawProgram.Instruction }): { YarnProgram.Instruction }
	local newCode = table.create(#code)

	for _, ins in ipairs(code) do
		local new = {}
		new.opcode = RawProgram.Opcodes[ins.opcode or "JUMP_TO" :: RawProgram.Opcode]
		new.operands = table.create(if ins.operands then #ins.operands else 0)

		if ins.operands then
			for _, operand in ipairs(ins.operands) do
				table.insert(new.operands, getOperand(operand))
			end
		end

		table.insert(newCode, new :: YarnProgram.Instruction)
	end

	return newCode
end

--- Decode a compiled Yarn program
--- :::note
---   This method will usually only be used by generated YarnSpinnerRbx scripts.
--- :::
--- @within Yarn
---
--- @param compiled RawProgram -- Compiled program data
--- @return string? -- Program name if exists
--- @return { [string]: YarnProgram.Node } -- Node lookup table
--- @return { [string]: YarnProgram.Operand } -- Initial values table
function Yarn.DecodeProgram(
	compiled: RawProgram
): (string?, { [string]: YarnProgram.Node }, { [string]: YarnProgram.Operand })
	local newNodes = {} :: { [string]: YarnProgram.Node }
	local newInitialValues = {} :: { [string]: YarnProgram.Operand }

	for key, node in compiled.nodes do
		newNodes[key] = {
			name = node.name,
			instructions = decodeInstructions(node.instructions),
			labels = node.labels or {},
			tags = node.tags or {},
			sourceTextStringID = node.sourceTextStringID,
			headers = node.headers or {},
		}
	end

	if compiled.initialValues then
		for key, val in compiled.initialValues do
			newInitialValues[key] = getOperand(val)
		end
	end

	return compiled.name, newNodes, newInitialValues
end

return table.freeze(Yarn)
